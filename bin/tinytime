#!/usr/bin/env python3

# tinytime: 6-character date and time format
#
# Copyright 2018 Antti Kervinen <antti.kervinen@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms and conditions of the GNU Lesser General Public
# License, version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA
# 02110-1301 USA.

r"""Usage: tinytime [COMMAND...]

Commands:
  epoch                 print epoch date and time with 3+3 characters.
  clock                 print local time with 3 characers.
  B60EPOCH              print base 60 epoch time as local time and date.
  /B60CLOCK             print base 60 local time as local time.
  B60EPOCH1-B60EPOCH2   print time difference in human readable format.

In B60EPOCH format first three symbols are specify the date, last
three digits the time.

B60EPOCH timestamp format:

4s5DW1
^^^^^^
|||||\.. seconds, symbols 0..9A..Za..x, x equals 59.
||||\... minutes, symbols 0..9A..Za..x
|||\.... hours, symbols 0..9A..N, N equals 23.
\\\..... days since 1970-01-01, symbols 0..9A..Za..x

Example: tiny timestamp in Bash prompt
  export PS1="\$(tinytime epoch) $PS1"

Example: show time since previous command and tiny timestamp in Bash prompt
  function tinytime_command_timer() {
      TINYTIME_LAST_CMD=$TINYTIME_RUN_CMD
      TINYTIME_RUN_CMD=$(HISTTIMEFORMAT= history 1);
      if [ "$TINYTIME_LAST_CMD" != "$TINYTIME_RUN_CMD" ]; then
          TINYTIME_RUN_START=$(tinytime epoch);
      fi
  }
  PS1='$(tinytime $(tinytime epoch)-$TINYTIME_RUN_START) $(tinytime epoch) '$PS1
  TINYTIME_RUN_START=$(tinytime epoch)
  trap tinytime_command_timer DEBUG
"""

import datetime
import os
import re
import sys
import time

# 24h "0:00" == "O:00"               O
# quarters                  F              U              j
symbols60 = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwx'
assert len(symbols60) == 60

def int_to_tinyb60(num):
    b60digits = []
    while num > 0:
        b60digits.append(symbols60[num % 60])
        num = num // 60
    return "".join(reversed(b60digits))

def epoch_to_tinyb60(num):
    # divisor: sec, min, h, the rest
    divisor = (60, 60, 24, 60, 60, 60, 60, 60, 60)
    b60digits = []
    i = 0
    while num > 0:
        b60digits.append(symbols60[num % divisor[i]])
        num = num // divisor[i]
        i += 1
    return "".join(reversed(b60digits))

def tinyb60_to_epoch(epoch_str):
    h_m_s = tinyb60_to_int(epoch_str[-3:])
    d = tinyb60_to_int(epoch_str[:-3])
    return d*60*60*24 + h_m_s

def tinyb60_to_int(tinyb60):
    num = 0
    syms = list(tinyb60)
    k = 1
    while syms:
        sym = syms.pop()
        try:
            num += k * symbols60.index(sym)
        except ValueError:
            raise ValueError('illegal symbol in tiny60 value: %r' % (sym,))
        k *= 60
    return num

def iso_to_int(iso8601):
    d = datetime.datetime.fromisoformat(iso8601)
    epoch_time = d.timestamp()
    return int(epoch_time)

def strfclock(clock_str):
    t = tinyb60_to_int(clock_str)
    s = str(t % 60).zfill(2)
    t //= 60
    m = str(t % 60).zfill(2)
    t //= 60
    h = str(t).zfill(2)
    return "%s:%s:%s" % (h, m, s)

def strfepoch(epoch_str, fmt="%F %T"):
    if os.name == "nt":
        fmt = fmt.replace("%F", "%Y-%m-%d").replace("%T", "%H:%M:%S")
    epoch_num = tinyb60_to_epoch(epoch_str)
    return datetime.datetime.fromtimestamp(epoch_num).strftime(fmt)

def timediff(seconds):
    unit = ("s", "m", "h", "d")
    divisor = (60, 60, 24)
    res = []
    t = seconds
    res.append("%ss" % (t % 60,))
    t //= 60
    if t > 0:
        res.append("%sm" % (t % 60,))
    t //= 60
    if t > 0:
        res.append("%sh" % (t % 24,))
    t //= 24
    if t > 0:
        res.append("%sd" % (t,))
    res.reverse()
    return "".join(res)

if __name__ == "__main__":
    if len(sys.argv) == 1:
        # no parameters, convert tinyepochs/clocks in stdin
        # supported timestamp syntaxes:
        # "%" 6_SYMBOL_DATE_TIME_EPOCH
        re_tinyb60_epochstamp = re.compile(r'(%%[%s]{6})([^%s]|$)' % (
            symbols60, symbols60))
        for line in sys.stdin:
            l = re_tinyb60_epochstamp.findall(line)
            for tinyb60, sth_else in l:
                formatted = strfepoch(tinyb60[1:])
                line = line.replace(tinyb60 + sth_else, "[" + formatted + "]" + sth_else)
            sys.stdout.write(line)
    else:
        for arg in sys.argv[1:]:
            if arg == "epoch":
                print(epoch_to_tinyb60(int(time.time())))
            elif arg == "clock": # local time
                t = datetime.datetime.now()
                int_t = (t.second +
                         t.minute * 60 +
                         t.hour   * 60 * 60)
                print(int_to_tinyb60(int_t))
            elif arg.count("-") >= 2: # ISO-8601 date or alike
                print(epoch_to_tinyb60(
                    iso_to_int(arg)))
            elif arg.startswith("/"):
                if "-" in arg:
                    clock_str_1, clock_str_2 = arg.split("-")
                    clock_1 = tinyb60_to_int(clock_str_1[1:])
                    clock_2 = tinyb60_to_int(clock_str_2[1:])
                    print(timediff(clock_2 - clock_1))
                else:
                    print(strfclock(arg[1:]))
            else:
                if "-" in arg:
                    epoch_str_1, epoch_str_2 = arg.split("-")
                    epoch_1 = tinyb60_to_epoch(epoch_str_1)
                    epoch_2 = tinyb60_to_epoch(epoch_str_2)
                    if epoch_1 >= epoch_2:
                        print(timediff(epoch_1 - epoch_2,))
                    else:
                        print("-%s" % (timediff(epoch_2 - epoch_1,),))
                else:
                    if len(arg) == 3: # hh:mm:ss only
                        print(strfepoch(arg, "%T"))
                    else:
                        print(strfepoch(arg))
