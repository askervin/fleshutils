#!/usr/bin/env python3
#
# Copyright (c) 2025 Antti Kervinen <antti.kervinen@gmail.com>
#
# License (MIT):
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

r"""csv-analyze [options] command [command-options] FILE...

Search data in FILE where data is formatted in a table:

result  param0  param1 ... paramN
    r0  p0val0  p1val0 ... pnval0
    r1  p0val1  p1val1 ... pnval1
   ...

Command: hit                         search parameter-value combinations
                                     that most likely hits given results.

  --results RESULTS                  RESULTS are given as a range: MIN-MAX or
                                     as a single value: VAL.

  --paramcombs COUNTS                calculate through all combinations
                                     COUNT parameters. The default is 1-N,
                                     that is, cover all parameter combinations
                                     from single up to all parameters.

Command: explain                     search for best hit, then exclude those
                                     results, and repeat for the remaining
                                     results until no more likely hits are
                                     found. Takes the same options as the hit
                                     command

Options:
  -h, --help
  -d, --delimiter DELIMITER          set field separator, the default is ";".

  --print-all                        print all searched elements.
  --print-improving                  print searched elements that improve
                                     the best result so far.

  --better-in-range MODE             set how results in search RESULTS range
                                     are treated when searching for the best
                                     parameter combinations. MODE can be
                                     "lower": close to MIN are better
                                     "higher": close to MAX are better
                                     "middle": close the middle are better
                                     "none": all results in range are equal.

"""

import csv
import getopt
import itertools
import math
import sys

# error prints error message and exits process
def error(msg, exit_status=1):
    if msg:
        sys.stderr.write("csv-query: %s\n" % (msg,))
    if exit_status is not None:
        sys.exit(exit_status)

def dump(params, data):
    # print header
    print("result", *params, sep=";")
    for row in data:
        print(*row, sep=";")

def parse_result_range(results):
    if "-" in results:
        parts = results.split("-", 1)
        try:
            rmin = opt_datatype(parts[0])
            rmax = opt_datatype(parts[1])
        except Exception:
            error("invalid result range '%s'" % (results,))
        if rmin > rmax:
            error("invalid result range '%s'" % (results,))
        return (rmin, rmax)
    else:
        try:
            rval = opt_datatype(results)
        except Exception:
            error("invalid result value '%s'" % (results,))
        return (rval, rval)

def parse_paramcombs(paramcombs, paramcount):
    parts = paramcombs.split(",")
    result = set()
    for part in parts:
        if "-" in part:
            subparts = part.split("-", 1)
            try:
                pmin = int(subparts[0])
                pmax = int(subparts[1])
            except Exception:
                error("invalid paramcombs range '%s'" % (part,))
            if pmin < 1 or pmax < 1 or pmin > pmax or pmax > paramcount:
                error("invalid paramcombs range '%s'" % (part,))
            for p in range(pmin, pmax + 1):
                result.add(p)
        else:
            try:
                p = int(part)
            except Exception:
                error("invalid paramcombs value '%s'" % (part,))
            if p < 1 or p > paramcount:
                error("invalid paramcombs value '%s'" % (part,))
            result.add(p)
    return sorted(result)

def params_data(data_reader):
    # data contains all rows data in a numeric format
    MISSING_VALUE = -1
    params = data_reader.fieldnames[1:]
    data = [[(opt_datatype(row[f]) if row[f].strip() != "" else MISSING_VALUE) for f in data_reader.fieldnames] for row in data_reader]
    print("Detected data table: result in column %s, parameters: %s, rows: %d" % (data_reader.fieldnames[0], ", ".join(params), len(data)))
    return (params, data)

def search_hits(params, data, results, paramcombs, except_rows={}):
    best_highscores = []
    comb_best_highscores = []
    max_highscores = 1
    def print_score(score_tuple, comb_tuple):
        nonlocal last_row_within_range, data
        pcomb, pcomb_value, comb_results, in_count, out_count, hit_rows = comb_tuple
        match_target = 0.0
        if last_row_within_range >= 0:
            match_target = in_count / (last_row_within_range + 1 - len(except_rows))
        match_all = (in_count + out_count) / len(data)
        print("%.3f %.3f %d %d min=%d max=%d avg=%.3f tgt=%d tot=%d tgtcov=%.3f totcov=%.3f where='%s'" % (
                score_tuple[0], score_tuple[1], score_tuple[2], score_tuple[3],
                min(comb_results), max(comb_results), sum(comb_results)/len(comb_results),
                in_count, in_count+out_count,
                match_target, match_all,
                " and ".join("%s==%s" % (params[i], pcomb_value[pi]) for pi, i in enumerate(pcomb))
                ))
    def update_highscores(highscores, max_highscores, score_tuple, comb_tuple):
        # TODO: consider alternative for highscore list:
        # how about constructing a set that covers as large a portion of
        # results in range as possible?
        if len(highscores) > 0 and score_tuple >= highscores[-1][0]:
            return False
        new_best = len(highscores)==0 or (score_tuple < highscores[0][0])
        highscores.append((score_tuple, comb_tuple))
        highscores.sort()
        if len(highscores) > max_highscores:
            highscores.pop()
        return new_best
    def print_highscores(highscores, title):
        print(title)
        for n, (score_tuple, comb_tuple) in enumerate(highscores):
            print("%d." % (n+1,), end=" ")
            print_score(score_tuple, comb_tuple)

    (rmin, rmax) = parse_result_range(results)
    # sort data so that rows with result in the given range come first
    data.sort(key=lambda row: (row[0] < rmin or row[0] > rmax, row[0]))

    last_row_within_range = -1
    for row_index, row in enumerate(data):
        if rmin <= row[0] <= rmax:
            last_row_within_range = row_index
        else:
            break

    # param_values[param_index] = {value0: datarows_with_value0, ...}
    param_values = [{} for _ in params]
    param_values_in_range = [{} for _ in params]
    for row_index, row in enumerate(data):
        for param_index in range(len(params)):
            pval = row[param_index + 1]
            rowset = param_values[param_index].get(pval, None)
            if rowset is not None:
                rowset.add(row_index)
            else:
                param_values[param_index][pval] = {row_index}
            if row_index == last_row_within_range:
                # Make a deep copy of param_values to param_values_in_range
                param_values_in_range[param_index] = {}
                for v, rset in param_values[param_index].items():
                    param_values_in_range[param_index][v] = set(rset)
    if last_row_within_range == -1:
        print("No results within range [%s,%s], going through all parameter values to find a combination with smallest error" % (rmin, rmax))
        for param_index in range(len(params)):
            param_values_in_range[param_index] = param_values[param_index]
    else:
        print("%d out of %d results within range [%s,%s]" % (last_row_within_range + 1, len(data), rmin, rmax))

    # Find parameter combinations that explain results in the given range.
    # First go through single parameters, then pairs, etc.
    pcomb_paramcount = 1
    print("score: ")
    print("1. root mean square error for out-of-range results, lower is better")
    print("2. root mean square error for in-range results, lower is better")
    print("3. total results not matching parameter combination, lower is better (indicates reliability)")
    print("4. parameter count, lower is better")
    print()
    for pcomb_paramcount in paramcombs:
        highscores = []
        for pcomb in itertools.combinations(range(len(params)), pcomb_paramcount):
            comb_params_within_range = set()
            pcomb_values_to_search = [param_values_in_range[i].keys() for i in pcomb]
            for pcomb_value in itertools.product(*pcomb_values_to_search):
                rows_with_param_value_comb = None
                for pi in range(len(pcomb)):
                    param_index = pcomb[pi]
                    param_val = pcomb_value[pi]
                    rows_with_param_value = param_values[param_index][param_val]
                    if rows_with_param_value_comb is None:
                        rows_with_param_value_comb = set(rows_with_param_value)
                    else:
                        rows_with_param_value_comb.intersection_update(rows_with_param_value)
                    if len(rows_with_param_value_comb) == 0:
                        break
                if rows_with_param_value_comb is not None:
                    rows_with_param_value_comb.difference_update(except_rows)
                if rows_with_param_value_comb is None or len(rows_with_param_value_comb) == 0:
                    continue # no results with this param-value combination, next value combination

                comb_rows_count = len(rows_with_param_value_comb)
                results = [data[r][0] for r in rows_with_param_value_comb]
                outside_sqrerrors = [(result - rmin) ** 2 if result < rmin else (result - rmax) ** 2
                                           for result in results if result < rmin or result > rmax]
                outside_count = len(outside_sqrerrors)
                score_outside_rmse = 0 if outside_count == 0 else math.sqrt(sum(outside_sqrerrors)/outside_count)

                if opt_better_in_range == "lower":
                    inside_sqrerrors = [(result - rmin) ** 2 for result in results if rmin <= result <= rmax]
                elif opt_better_in_range == "higher":
                    inside_sqrerrors = [(result - rmax) ** 2 for result in results if rmin <= result <= rmax]
                elif opt_better_in_range == "middle":
                    middle = (rmin + rmax) / 2
                    inside_sqrerrors = [(result - middle) ** 2 for result in results if rmin <= result <= rmax]
                elif opt_better_in_range == "none":
                    inside_sqrerrors = [0 for result in results if rmin <= result <= rmax]
                score_inside_rmse = 0 if len(inside_sqrerrors) == 0 else math.sqrt(sum(inside_sqrerrors)/len(inside_sqrerrors))
                score_param_count = len(pcomb)

                score_dropped_combs = len(data) - comb_rows_count

                score_tuple = (
                    score_outside_rmse,
                    score_inside_rmse,
                    score_dropped_combs,
                    score_param_count,
                )
                comb_tuple = (
                    pcomb,
                    pcomb_value,
                    results,
                    comb_rows_count - outside_count,
                    outside_count,
                    rows_with_param_value_comb,
                )
                print_this = opt_print_all

                if update_highscores(comb_best_highscores, max_highscores, score_tuple, comb_tuple):
                    if update_highscores(best_highscores, max_highscores, score_tuple, comb_tuple):
                        if opt_print_improving:
                            print("new best", end=" ")
                            print_this = True
                if print_this:
                    print_score(score_tuple, comb_tuple)
        print_highscores(comb_best_highscores, "Top %d of %d parameter-value combinations" % (max_highscores, pcomb_paramcount))
        comb_best_highscores = []
    if best_highscores:
        print_highscores(best_highscores, "Top %d combination from all combinations" % (max_highscores,))
        return best_highscores[0]
    return None

if __name__ == "__main__":
    import getopt
    opt_command = None
    opt_delimiter = ";"
    opt_print_all = False
    opt_print_improving = True
    opt_results = None
    opt_paramcombs = None
    opt_better_in_range = "lower"
    opt_files = []
    opt_datatype = int

    try:
        opts, remainder = getopt.gnu_getopt(
            sys.argv[1:], 'hd:',
            ['help', 'delimiter=',
             'print-all',
             'print-improving',
             'results=',
             'paramcombs=',
             'better-in-range=',
             ])
    except Exception as e:
        error(str(e))
    for opt, arg in opts:
        if opt in ["-h", "--help"]:
            print(__doc__)
            sys.exit(0)
        elif opt in ["-d", "--delimiter"]:
            opt_delimiter = arg
        elif opt in ["--print-all"]:
            opt_print_all = True
        elif opt in ["--print-improving"]:
            opt_print_improving = True
        elif opt in ["--results"]:
            opt_results = arg
        elif opt in ["--paramcombs"]:
            opt_paramcombs = arg
        elif opt in ["--better-in-range"]:
            if arg in ["lower", "higher", "middle", "none"]:
                opt_better_in_range = arg
            else:
                error("invalid --better-inside-range mode '%s'" % (arg,))
        else:
            error("internal error: unimplemented option '%s'" % (opt,))

    if len(remainder) == 0:
        error("command missing")

    opt_command = remainder[0]
    remainder = remainder[1:]

    opt_files.extend(remainder)
    if len(opt_files) == 0:
        opt_files.append("-")

    for fname in opt_files:
        if fname == "-":
            data_reader = csv.DictReader(sys.stdin, delimiter=opt_delimiter)
        else:
            data_reader = csv.DictReader(open(fname), delimiter=opt_delimiter)

    if opt_command == "hit" or opt_command == "explain":
        if opt_paramcombs is None:
            opt_paramcombs = range(1, len(data_reader.fieldnames))
        else:
            opt_paramcombs = parse_paramcombs(opt_paramcombs, len(data_reader.fieldnames)-1)
        if opt_results is None:
            error("--results=RESULTS missing")
        (params, data) = params_data(data_reader)
        if opt_command == "hit":
            search_hits(params, data, opt_results, opt_paramcombs)
        elif opt_command == "explain":
            explanations = []
            searched_rows = set()
            while True:
                best_hit = search_hits(params, data, opt_results, opt_paramcombs, searched_rows)
                if best_hit is None:
                    break
                (score_tuple, comb_tuple) = best_hit
                (pcomb, pcomb_value, comb_results, in_count, out_count, hit_rows) = comb_tuple
                searched_rows.update(hit_rows)
                explanations.append(best_hit)
                for expl in explanations:
                    print("---")
                    (score_tuple, comb_tuple) = expl
                    (pcomb, pcomb_value, comb_results, in_count, out_count, hit_rows) = comb_tuple
                    print("Explained %d results with parameter combination: %s" % (in_count, " and ".join("%s==%s" % (params[i], pcomb_value[pi]) for pi, i in enumerate(pcomb))))
    #print("Explained %d results with parameter combination: %s" % (in_count, " and ".join("%s==%s" % (data_reader.fieldnames[i+1], pcomb_value[pi]) for pi, i in enumerate(pcomb))))
                if out_count > 0:
                    print("  Note: %d results outside range" % (out_count,))
    else:
        error("invalid command '%s'" % (opt_command,))
